WebSocketDS
===========

- **[установка.](#установка)**
- **[перечень property для определения Tango устройства.](#перечень-property-для-определения-tango-устройства)**
- **[перечень атрибутов](#перечень-атрибутов)**
- **[свойство Options](#свойство-options)**
- **[режимы работы tango-модуля](#режимы-работы-tango-модуля)**
- **[простое использование только с чтением атрибутов](#простое-использование-только-с-чтением-атрибутов)**
  - **[периодическое чтение атрибутов с прослушиваемого TangoDevice.](#периодическое-чтение-атрибутов-с-прослушиваемого-tangodevice)**
  - **[периодическое чтение атрибутов с группы прослушиваемых TangoDevice.](#чтение-атрибутов-с-группы-прослушиваемых-tangodevice)**
  - **[чтение атрибутов с прослушиваемого TangoDevice по запросу.](#чтение-атрибутов-с-прослушиваемого-tangodevice-по-запросу)**
  - **[чтение атрибутов с группы прослушиваемых TangoDevice по запросу.](#чтение-атрибутов-с-группы-прослушиваемых-tangodevice-по-запросу)**
- **[чтение с pipe подключаемых устройств](#чтение-с-pipe-подключаемых-устройств)**
  - **[чтение с pipe в атрибутном режиме](#чтение-с-pipe-в-атрибутном-режиме)**
  - **[чтение с pipe в командном режиме](#чтение-с-pipe-в-командном-режиме)**
- **[дополнительные параметры для атрибутов, pipe и команд](#дополнительные-параметры-для-атрибутов-pipe-и-команд)**
  - **[команды с выводом в двоичном формате](#команды-с-выводом-в-двоичном-формате)**
  - **[изменение точности и форматирование выводимых значений атрибутов, pipe и команд типа с плавающей запятой](#изменение-точности-и-форматирование-выводимых-значений-атрибутов-pipe-и-команд-типа-с-плавающей-запятой)**
  - **[установление периодичности вывода значений для атрибутов](#установление-периодичности-вывода-значений-для-атрибутов)**
- **[запуск команд](#запуск-команд)**
  - **[запуск команд в режиме танго-девайса](#запуск-команд-в-режиме-танго-девайса)**
  - **[запуск команд в режиме группы танго-девайсов](#запуск-команд-в-режиме-группы-танго-девайсов)**
  - **[запуск команд в клиентном режиме](#запуск-команд-в-клиентном-режиме)**
  - **[запись в атрибуты в режиме танго-девайса](#запись-в-атрибуты-в-режиме-танго-девайса)**
  - **[запись в атрибуты в режиме группы танго-девайсов](#запись-в-атрибуты-в-режиме-группы-танго-девайсов)**
  - **[запись в атрибуты в клиентном режиме](#запись-в-атрибуты-в-клиентном-режиме)**
  - **[общая информация по командам](#общая-информация-по-командам)**
- **[клиентный запуск команд и чтение данных с атрибутов или pipe](#клиентный-запуск-команд-и-чтение-данных-с-атрибутов-или-pipe)**
  - **[клиентное чтение атрибутов и pipe](#клиентное-чтение-атрибутов-и-pipe)**
  - **[клиентный запуск команд](#клиентный-запуск-команд)**
  - **[клиентная запись в атрибуты](#клиентная-запись-в-атрибуты)**
- **[работа с событиями](#работа-с-событиями)**
  - **[подписка на события](#подписка-на-события)**
  - **[полная отписка от событий](#полная-отписка-от-событий)**
  - **[частичная отписка от событий](#частичная-отписка-от-событий)**
  - **[получение id подписки](#получение-id-подписки)**
- **[использование USERANDIDENT для авторизации.](#использование-userandident-для-авторизации)**
  - **[авторизация методом USERANDIDENT во время подключения](#авторизация-методом-userandident-во-время-подключения)**
  - **[авторизация методом USERANDIDENT после подключения](#авторизация-методом-userandident-после-подключения)**
  - **[авторизация методом USERANDIDENT2 после подключения](#авторизация-методом-userandident2-после-подключения)**
- **[авторизация методом permission_www](#авторизация-методом-permission_www)**
- **[использование записи в журнал при выполении команд](#использование-записи-в-журнал-при-выполении-команд)**
- **[формат возвращаемых ошибок](#формат-возвращаемых-ошибок)**
- **[список типов запроса](#список-типов-запроса)**

## установка.
Для успешной компиляции должны быть установлены библиотеки TANGO и компилятор с поддержкой c++11. Также должны быть установлены __libboost-system libboost-system-dev libssl__

В директории есть Makefile для g++. Данный Makefile был генерирован POGO, и при стандартных сборках TANGO подходит в большинстве случаев. Для успешного запуска данного Makefile, должна присутствовать директория определённая в  `MAKE_ENV = /usr/local/share/pogo/preferences` (по умолчанию. При необходимости нужно поправить). В скриптах, содержащихся в директории, определены необходимые переменные окружения для сборки проекта.

По умолчанию компиляция идёт в режиме OPTIMIZED (-O2). Для компиляции в режиме DEBUG (-g -D_DEBUG) нужно запустить `make RTYPE=debug`, предварительно набрав `make clean`

## перечень property для определения Tango устройства.
 - **Mode** — Используемый режим работы модуля. Подробнее про типы режимов [описано ниже](#режимы-работы-tango-модуля)
 - **Port** — Прослушиваемый порт при соединении; (DevShort)
 - **DeviceServer** - tango id используемого устройства. Пример: `test/psw/group`. В случае использования групп устройств, используется шаблон. Параметром шаблона может быть простое имя устройства или шаблон имени устройства (например, `domain_*/family/member_*`); (string)
 - **Attributes** — список атрибутов устройства, которые вы хотите считывать, если требуется считывать все атрибуты добавьте `__all_attrs__` (в групповом режиме не действует)`(если используется один из Server Mode)`; (array of string)
 - **Commands** — список команд устройства, которые вы хотите выполнять через WS `(если используется один из Server Mode)`, если требуются включить все команды добавьте `__all_commands__`; (array of string)
 - **PipeName** - PipeName для pipe устройства, также список атрибутов с опциями для вывода. `(если используется один из Server Mode)`; (array of string)
 - **AuthDS** — танго сервер, отвечающий за аутентификацию пользователя, при наличии исполняемых команд; (string)
 - **Secure** — установите true, для использования защищённого wss соединения, иначе false; (bool)
 - **Certificate** — полный путь к используемому сертификату (if Secure = true); (string)
 - **Key** - полный путь к используемому файлу с  Private key (if Secure = true); (string)
 - **MaxNumberOfConnections** - максимальное число соединений. Если будет достигнут предел, последующие соединения будут прерваны ошибкой `400 Bad Request`. Если задано значение 0, количество соединений не будет ограничено.; (DevUShort)
 - **MaximumBufferSize** - максимальный размер буфера для каждого соединения в КиБ. Значение по умолчанию 1000. Возможные значения от 1 до 10000 (если указать значения не входящие в заданный диапазон будет выставлено значение по умолчанию). При превышении заданного максимального размера буфера, соединение будет прервано со стороны сервера; (DevULong)
 - **ResetTimestampDifference** - Разница таймстампов (в секундах) после которого будет произведена перезагрузка WS сервера. Расчёт разницы производится в методе CheckPoll между тайстампом обновляемым в методе UpdateData и текущим таймстампом. Минимальное значение 60.; (DevUShort)
 - **Options** - дополнительные опции. Перечень дополнительных опций для девайса. Подробнее про список дополнительных опций будет [указано ниже](#свойство-options). (array of string)
 - **list_subscr_event_change** - Перечень атрибутов с подпиской на события `CHANGE_EVENT`. `(если используется один из Server Mode)`; (array of string)
 - **list_subscr_event_periodic** - Перечень атрибутов с подпиской на события `PERIODIC_EVENT`. `(если используется один из Server Mode)`; (array of string)
 - **list_subscr_event_user** - Перечень атрибутов с подпиской на события `USER_EVENT`. `(если используется один из Server Mode)`; (array of string)
 - **list_subscr_event_archive** - Перечень атрибутов с подпиской на события `ARCHIVE_EVENT`. `(если используется один из Server Mode)`; (array of string)

 <h2><b style="color:red;"> В методе CheckPoll проверяется сколько секунд прошло после последнего запуска метода UpdateData. Если значение превысит, заданное в property, количество секунд, произойдёт перезагрузка девайс-сервера.  Не выставляйте значение polling для UpdateData близким к значению ResetTimestampDifference</b></h2>

## перечень атрибутов
 - **TimestampDiff** - текущая разница таймстампов (обновляется в методе CheckPoll. Значение Polling по умолчанию для него 10 секунд); (DevULong)
 - **NumberOfConnections** - текущее число клиентов (соединений). (DevULong)

## свойство Options
  Свойство Options (array of strings) для танго-девайса имеет формат `opt1` либо `opt2=val`, где `opt` - имя опции, `val` - значение, если присутствует.

  Перечень доступных опций:
  - **group** - Без дополнительных значений. Использование групп девайс серверов. Свойство `DeviceServer` должно быть задано в соответствующем для групп формате.
  - **uselog** - Без дополнительных значений. Использование записи в журнал при выполении команд.  [Подробнее ниже](#использование-записи-в-журнал-при-выполении-команд)
  - **tident** - С дополнительным значением. Используемый тип авторизации. Используются несколько типов `rndid` - RANDIDENT, `rndid2` - RANDIDENT2 ([подробности ниже](#использование-userandident-для-авторизации)), `permission_www`  ([подробности ниже](#авторизация-методом-permission_www)), а также `smpl` - SIMPLE (он же используется по умолчанию)
  - **tm100ms** - Без дополнительных значений. По умолчанию, минимальное значение для периода обновления установленного клиентом должно быть больше либо равно 1000 мсек. При установке данного параметра в Options минимальное значение будет 100 ms.

## режимы работы tango-модуля

Танго модуль запускается в одном из перечисленных режимов:

  - **SERVER** - Только серверное управление выводом информации, считываемых с атрибутов и pipe. А также запуск команд в tango-модуле (или группе), прописанном в Property. В этом режиме модуль запускается по умолчанию.
  - **SERVNCLIENT_ALL_RO** - Серверное и клиентное управление выводом информации, считываемых с атрибутов и pipe. А также запуск команд в tango-модуле (или группе), прописанном в Property; option:  `ser_cli_all_ro`.
  - **SERVNCLIENT_ALL** -  Серверное и клиентное управление выводом информации, считываемых с атрибутов и pipe. Запуск команд в tango-модуле (или группе), прописанном в Property. Также запуск команд и чтение атрибутов с любых танго-модулей; option: `ser_cli_all`
  - **SERVNCLIENT_ALIAS_RO** - Серверное и клиентное управление выводом информации, считываемых с атрибутов и pipe. Запуск команд в tango-модуле (или группе), прописанном в Property. Запрещён запуск команд в модулях указанном клиентом. Чтение атрибутов только с танго-модулей, имеющих alias; option: `ser_cli_ali_ro`
  - **SERVNCLIENT_ALIAS** - Серверное и клиентное управление выводом информации, считываемых с атрибутов и pipe. Запуск команд в tango-модуле (или группе), прописанном в Property. Чтение атрибутов, а также запуск команд только с танго-модулей, имеющих alias; option: `ser_cli_ali`
  - **CLIENT_ALL_RO** - Клиентное управление выводом информации, считываемых с атрибутов и pipe. При использовании данного режима, из сервера приходят только данные, определённые пользователем. Также запрещён запуск команд; option: `cli_all_ro`
  - **CLIENT_ALL** - Клиентное управление выводом информации, считываемых с атрибутов и pipe. При использовании данного режима, из сервера приходят только данные, определённые пользователем. Возможен запуск команд на любых танго-модулях; option: `cli_all`
  - **CLIENT_ALIAS_RO** - Клиентное управление выводом информации, считываемых с атрибутов и pipe только с танго-модулей, имеющих alias. При использовании данного режима, из сервера приходят только данные, определённые пользователем.; option: `cli_ali_ro`
  - **CLIENT_ALIAS** - Клиентное управление выводом информации, считываемых с атрибутов и pipe,  только с танго-модулей, имеющих alias. При использовании данного режима, из сервера приходят только данные, определённые пользователем. Также возможен запуск команд только с танго-модулей, имеющих alias; option: `cli_ali`

Для включение режима, отличного от SERVER, нужно добавить в Property `Mode` значение, заданнoе для режима. 
[Подробнее про управление выводом информации](#клиентное-управление-обновляемым-выводом-информации)

## простое использование только с чтением атрибутов

Для использования  WS только для чтения атрибутов, следует определить `Port`,  `DeviceServer` (или Group) и список `Attributes` которые будут читаться. При использовании защищённого wss соединения, нужно установить свойство `Secure` в true, а также определить  `Certificate`  и `Key`.

[Подробнее про JSON можно прочитать здесь](http://www.json.org/json-ru.html)

#### периодическое чтение атрибутов с прослушиваемого TangoDevice.

По умолчанию вид формата получаемых данных будет следующим:
```json
{
	"event": "read",
	"type_req":"attribute",
	"data": {
		"attribute_name": {
			"data": "data",
			"set": "if writable attribute"
		}
	},
	"pipe":
		{
			"attrName1" : "Data in format dependent on type",
			"attrName2" : ["Data in format", "dependent on type"]
		}
}
```

[Старая версия](./old_version.md#server-mode-attributes). Чтобы использовать старую версию допишите в Property `Options` - `array_out`

Также может быть добавлены значения UNIX_TIMESTAMP `"time"` и `Tango::AttrQuality` `"qual"` . По умолчанию `Tango::AttrQuality` выводится только если оно не равно `VALID`.

```json
{
	"attr": "имя_атрибута",
	"qual": "VALID",
	"time": 1475580424,
	"data": 128
}
```

Для добавления этих значений нужно добавить значение `notshrtatt` в Property `"Options"` ([подробнее про формат опций здесь](#свойство-options))



 * **"event"** - тип события, в данном случае чтение
 * **"type_req"** - тип полученных данных, в данном случае attribute. Данные с прослушиваемых атрибутов.
 * **"data"** - Получаемые данные. (Атрибуты)

   * **"attr"** — имя прослушиваемого атрибута.
   * **"qual"** — `Tango::AttrQuality` Возможные значения: `"VALID`", `"INVALID"`,`"ALARM"`, `"CHANGING"`, `"WARNING"`;
   * **"time"** — UNIX_TIMESTAMP
   * **"data"** — Данные. В зависимости от типа читаемых атрибутов (Scalar, Spectrum,  Image) меняется выводимый формат. Для Scalar — это единственное значение в виде строки, числа или булевого значения. Для  Spectrum — это массив вида [ … ], также определено значение `"dimX"` размерность спектра. Для  Image— это это массив вида [ … ], также определено значение `"dimX"` и `"dimY"` -  размерность Image.

При возникновении ошибок при чтении атрибутов выводится JSON сообщение об ошибке. Формат описан ниже в разделе `"[Формат возвращаемых ошибок](#формат-возвращаемых-ошибок)"`

#### периодическое чтение атрибутов с группы прослушиваемых TangoDevice.

Пример формата получаемых данных c группы девайсов будет следующим:

```json
{
	"event": "read",
	"type_req":"group_attribute",
	"data":
	{
		"name/tango/device_from_group": {
			"attribute_name": {
			"data": "data",
			"set": "if writable attribute"
			}
		}
	}
}
```

[Старая версия](./old_version.md#server-mode-attributes-for-group). Чтобы использовать старую версию допишите в Property `Options` - `array_out`

Также может быть добавлены значения UNIX_TIMESTAMP `"time"` и `Tango::AttrQuality` `"qual"` . По умолчанию `Tango::AttrQuality` выводится только если оно не равно `VALID`.

```json
{
	"attr": "имя_атрибута",
	"qual": "VALID",
	"time": 1475580424,
	"data": 128
}
```

Для добавления этих значений нужно добавить значение `notshrtatt` в Property `"Options"` ([подробнее про формат опций здесь](#свойство-options))

* **"event"** - тип события, в данном случае чтение
* **"type_req"** - тип полученных данных, в данном случае `group_attribute`. Данные с прослушиваемых атрибутов.
* **"data"** - Получаемые данные. (Атрибуты)

  * **"name/tango/device_from_group"** - имя танго-девайса из группы
  * **"attr"** — имя прослушиваемого атрибута.
  * **"qual"** — `Tango::AttrQuality` Возможные значения: `"VALID`", `"INVALID"`,`"ALARM"`, `"CHANGING"`, `"WARNING"`;
  * **"time"** — UNIX_TIMESTAMP
  * **"data"** — Данные. В зависимости от типа читаемых атрибутов (Scalar, Spectrum,  Image) меняется выводимый формат. Для Scalar — это единственное значение в виде строки, числа или булевого значения. Для  Spectrum — это массив вида [ … ], также определено значение `"dimX"` размерность спектра. Для  Image— это это массив вида [ … ], также определено значение `"dimX"` и `"dimY"` -  размерность Image.


Если возникает ошибка при чтении с отдельного девайса из группы, формат data для него будет таким:

```json
{
	"name/tango/device_from_group" : "Error message"
}
```

#### чтение атрибутов с прослушиваемого TangoDevice по запросу.

При прослушивании одного устройства для чтения атрибута по запросу, отправляется сообщение следующего вида:

```json
{
	"type_req" : "read_attr",
	"attr_name": "name of attribute or array of names"
}
```

#### чтение атрибутов с группы прослушиваемых TangoDevice по запросу.

При прослушивании группы для чтения атрибута со всей группы по запросу, отправляется сообщение следующего вида:

```json
{
	"type_req" : "read_attr_gr",
	"attr_name": "name of attribute or array of names"
}
```

Для чтения атрибута с устройства из группы по запросу, отправляется сообщение следующего вида:

```json
{
	"type_req" : "read_attr_dev",
	"attr_name": "name of attribute or array of names"
}
```

## чтение с pipe подключаемых устройств

Чтение возможно в атрибутном и командном режимах:
 - В атрибутном режиме, данные с pipe считываются при обновлении данных вместе с атрибутами и добавляются в соответствующий JSON-output.
 - В командном режиме, данные с pipe считываются при запросе. Отправляется JSON-input в необходимом формате (описано ниже).

#### чтение с pipe в атрибутном режиме

PipeName имеет тип `array of string`. Для чтения данных с pipe подключаемых устройств в атрибутном режиме, в Свойство PipeName[0] должно быть добавлено pipe_name - имя pipe читаемого устройства.
Для форматирования вывода отдельных сегментов pipe, нужно добавить в свойство строки с именами сегмента, и необходимыми типами форматирования. Подробнее описано в разделе "[Дополнительные параметры для атрибутов, pipe и команд](#дополнительные-параметры-для-атрибутов-pipe-и-команд)"

В атрибутном режиме подключаться можно к единственному pipe из девайса.

При наличии PipeName в свойстве, к JSON, получаемом при чтении атрибутов, добавляется строка в следующем формате:

__В случае успеха:__

  a) __для девайса:__

  ```json
	{ "данные_с атрибутов" : "данные",
		"pipe":
		{
			"attrName1" : "данные в формате зависящем от типа",
			"attrName2" : ["данные в формате", "зависящем от типа"]
		}
	}
  ```
  b) __для группы:__

 ```json
	{ "данные_с атрибутов" : "данные",
		"pipe":
		{
			"nameof/tango/device":
			{
				"attrName1" : "данные в формате зависящем от типа",
				"attrName2" : ["данные в формате", "зависящем от типа"]
			}
		}
	}
 ```

__В случае ошибки:__

  a) __для девайса:__

   ```json
	{ "данные_с атрибутов" : "данные",
		"pipe" : "Error message"
	}
   ```

   b) __для группы:__

   ```json
	{ "данные_с атрибутов" : "данные",
		"pipe":
		{
			"nameof/tango/device": "Error message"
		}
	}
   ```

   `"Error message"` - может быть также массивом сообщений в формате `["Сообщение1", "Сообщение2"]`

#### чтение с pipe в командном режиме

Для чтения с pipe в командном режиме на сервер отправляется JSON сообщение в следующем формате:

```json
{     
	"type_req": "read_pipe or read_pipe_dev or read_pipe_gr",
	"pipe_name": "PipeName",
	"device_name": "!!!Только при чтении с конкретного девайса в групповом режиме!!!",
	"id": "id для идентификации запроса"
}
```

  * __"read_pipe or read_pipe_dev or read_pipe_gr"__: Имя читаемого pipe. Используется `"read_pipe"`в режиме одного девайса. `"read_pipe_dev"` в режиме `group`, для чтения с конкретного девайса из группы. `"read_pipe_gr"` в режиме `group`, для чтения со всех девайсов из группы.
  * __"device_name"__: Имя девайса в режиме `group`, для чтения с конкретного девайса из группы.
  * __"id"__: Идентификация запроса.  Значение для id может быть как числом, так и строкой. В случае, если id не указан, возвращается `"id": "None"`.

Для форматирования вывода отдельных сегментов pipe, нужно добавить в свойство строки с именами сегмента, и необходимыми типами форматирования. Подробнее описано в разделе "[Дополнительные параметры для атрибутов, pipe и команд](#дополнительные-параметры-для-атрибутов-pipe-и-команд)"

  - Ответ для `"read_pipe"`в режиме одного девайса будет таким:

  ```json
  {
  	"event": "read",
  	"type_req": "read_pipe",
  	"id_req": 1,
  	"data": {
  		"AttrName": "данные",
  		"AttrName2": ["данные", "данные"]
  	}
  }
  ```

  - Для `"read_pipe_dev"` в режиме `group`:

  ```json
  {
  	"event": "read",
  	"type_req": "read_pipe_dev",
  	"device_name": "name/tango/device_from_group",
  	"id_req": "id запроса запуска команды",
  	"data": {
  		"AttrName": "данные",
  		"AttrName2": ["данные", "данные"]
  	}
  }
  ```

  - Для чтения со всех девайсов из группы `"read_pipe_gr"` в режиме `group`:

  ```json
  {
  	"event": "read",
  	"type_req": "read_pipe_gr",
  	"device_name": "name/tango/device_from_group",
  	"id_req": "id запроса запуска команды",
  	"data" : {
  		"name/tango/device_from_group": {
  			"AttrName": "данные",
  			"AttrName2": ["данные", "данные"]
  		},
  		"name/tango/other_device_from_group": "Возможное сообщение об ошибке, либо [массив сообщений]"
  	}
  }
  ```

 При возниконовении ошибки, в зависимости от режима работы и типа команды, сообщение либо добавляется в JSON-output для группы в раздел девайса, в котором возникла ошибка, либо выводится общее сообщение об ошибке в формате, описанном ниже в разделе "[Формат возвращаемых ошибок](#формат-возвращаемых-ошибок)"


## дополнительные параметры для атрибутов, pipe и команд

Для выставления дополнительных параметров к имени атрибута или команды в свойстве следует добавить строку в следующем формате `;param=val` если требуется значение, или `;param` если значение не требуется.

Также можно добавлять несколько параметров в аналогичном формате.
Пример:

```
CommandOrAttrName;par1=val;par2;par3=34
```

Если в свойстве для атрибутов выставлен `__all_attrs__`, выставляются параметры для перечисленных атрибутов

В случае pipe в атрибутном режиме в свойстве PipeName можно выставить дополнительно параметры для отдельных атрибутов, передаваемых через pipe. Все имена атрибутов с параметрами должны идти после имени для DevicePipe.
Пример:

```
PipeName
AttrName;par1=val;par2
```

В случае pipe в командном режиме, параметры для отдельных атрибутов выставляются в property `Commands`. К имени атрибута должно добавляться `;pipecomm`, а также необходимый параметр.

```
AttrName;pipecomm;par1=val;par2
```

Список доступных на данный момент параметров для команд и атрибутов:

 - Для атрибутов, команд и pipe: **precf**, **precs**, **prec**
 - Только для атрибутов: **niter**
 - Только для команд: **bindata**


#### команды с выводом в двоичном формате

Для вывода в двоичном формате к имени команды в свойстве танго-девайса "Commands" должно быть добавлено `;bindata`.

Обратите внимание, что данный вывод поддерживается только для команд с типом возвращаемого значения `Tango::DEVVAR_CHARARRAY`. Также, если используется групповой режим, команды выполняются только для отдельных девайсов из группы. Для всей группы данный формат не поддерживается.

В случае какой-либо ошибки возвращается сообщение в формате JSON. Формат сообщения описан в разделе  "[Формат возвращаемых ошибок](#формат-возвращаемых-ошибок)"

#### изменение точности и форматирование выводимых значений атрибутов, pipe и команд типа с плавающей запятой

По умолчанию, для вывода данных атрибутов, pipe и команд стоит setprecision(5). Для выставления других значений точности, к имени атрибута в свойстве следует добавить `;prec=N`, где N - это требуемая точность. Пример: `AttrDevDouble;prec=10`

Следует учитывать максимально возможную точность. Подробнее про double можно посмотреть [здесь](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8), про float [здесь](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9).

Также возможно выставление дополнительных флагов форматирования:

- **precf** - выставление флага std::fixed
- **precs** - выставление флага std::scientific

Пример вывода для числа 1476379200 типа double с precision=10

- **;prec=10** - выводится 1476379200
- **;precf=10** - выводится 1476379200.0000000000
- **;precs=10** - выводится 1.4763792000e+009

Пример вывода для числа 1476379200 типа double с precision по умолчанию
- **;precf** - выводится 1476379200.000000
- **;precs** - выводится 1.476379e+009


Выставление точности для возвращаемых значений команд проходит аналогично.  Для выставления других значений точности, к имени команды в свойстве следует добавить `;prec=N`, либо другое, из перечисленного выше.

#### установление периодичности вывода значений для атрибутов

Для отдельных атрибутов можно выставить периодичность вывода. Для выставления перодичности к имени атрибута в свойстве следует добавить `;niter=N/M` либо `;niter=N`

Здесь
 - **N** - вывод раз в N итераций.  (unsigned short)
 - **M** - в какую итерацию в пределах периода выводить. `M` должно быть меньше `N`. По умолчанию `0` (unsigned short)


## запуск команд
Для запуска команд через  WS, нужно определить список запускаемых команд в свойстве  Commands. Команды, перечисленные в свойстве, должны содержаться в прослушиваемом девайсе. Если используется группа девайсов, перечисляемые команды должны быть во всех девайсах из группы (с аналогичной сигнатурой и типом возвращаемого значения. Сверяется Tango::CommandInfo для команд)

Также для возможности выполнения команд статус `check_user` должен быть `true`.

Проверить статус текущего подключения можно, отправив запрос

```json
{
	"type_req": "user_status",
	"id": "id запроса запуска команды"
}
```

В ответ приходит следующее сообщение:

```json
{
	"event": "read",
	"type_req": "user_status",
	"id_req": "id запроса запуска команды",
	"data": {
		"status": "true or false"
	}
}
```

#### запуск команд в режиме танго-девайса

Команды запускаются входящим json сообщением вида:
```json
{
	"type_req": "command",
	"id": "id запроса запуска команды",
	"command_name": "имя команды",
	"argin" : ["1","2","3"]
}
```

`argin` в зависимости от метода, отправляется либо в виде единичного значения, либо в виде массива. Если команда не принимает аргументов, `argin` не  указывать. Также можно указывать `"id": id`, для идентификации запроса. В случае, если id не указан, возвращается `"id": "None"`. значение для id может быть как числом, так и строкой.

Ответ в успешном случае будет таким:
```json
{
	"event": "read",
	"type_req": "command",
	"id_req": "id запроса запуска команды",
	"data": {
		"command_name": "имя команды",
		"argout": "Данные. Единственное значение [или массив]"
	}
}
```

В случае ошибки, возвращается JSON_ERROR_MESSAGE. Формат данного сообщения описан в разделе  "[Формат возвращаемых ошибок](#формат-возвращаемых-ошибок)"

#### запуск команд в режиме группы танго-девайсов

Команды запускаются json сообщением.

- Для всей группы запрос будет таким:

  ```json
  {
  	"type_req": "command_group",
  	"id": "id запроса запуска команды",
  	"command_name": "имя команды",
  	"argin" : ["1","2","3"]
  }
  ```

  Ответ, будет таким:

  ```json
  {
  	"event": "read",
  	"type_req": "command_group",
  	"id_req": "id запроса запуска команды",
  	"data": {
  		"command_name": "имя команды",
  		"argout": {
  			"name/tango/device_from_group" : "Данные в формате зависящем от возвращаемого типа",
  			"name/tango/other_device_from_group": {
  				"errors": "Возможное сообщение об ошибке, либо [массив сообщений]"
  			}
  		}
  	}
  }
  ```  

- Для отдельного девайса из группы запрос будет таким:

  ```json
  {
  	"type_req": "command_device",
  	"id": "id запроса запуска команды",
  	"command_name": "имя команды",
  	"device_name": "имя/танго/девайса",
  	"argin" : ["1","2","3"]
  }
  ```

  Ответ, в успешном случае, будет таким:

  ```json
  {
  	"event": "read",
  	"type_req": "command_device",
  	"id_req": "id запроса запуска команды",
  	"data": {
  		"command_name": "имя команды",
  		"device_name": "name/tango/device_from_group",
  		"argout": "Данные в формате зависящем от возвращаемого типа"
  	}
  }
  ```

  В случае ошибки, возвращается JSON_ERROR_MESSAGE. Формат данного сообщения описан в разделе  "[Формат возвращаемых ошибок](#формат-возвращаемых-ошибок)"

#### запуск команд в клиентном режиме

В клиентом режиме возможен запуск команд в любых танго-устройствах. Соответствующие права должны быть прописаны в базе и проверка проводится в подключённом модуле AuthDS. Подробнее описано в разделе [Клиентный запуск команд и чтение данных с атрибутов или pipe](#клиентный-запуск-команд-и-чтение-данных-с-атрибутов-или-pipe)

#### запись в атрибуты в режиме танго-девайса

Для записи в атрибуты в режиме танго-девайса необходимо отправить сообщение следующего вида:

```json
{
  	"type_req": "write_attr",
	"attr_name": "Attribute name",
	"id": "Request id",
	"argin": "value or [array]",
	"dimX": "only for Image type",
	"dimY": "only for Image type"
}
```

Здесь `"dimX"` и  `"dimY"` используются только для массивов типа `Image`. Для `Spectrum` `"dimX"` выставляется автоматически, исходя из присланных данных.

Для возможности записи данных в атрибуты, они должны быть перечислены в Property `Attributes` с постфиксом `wrt`, либо с постфиксом `onlywrt`. С `onlywrt` атрибут не будет внесён в список обновления.

#### запись в атрибуты в режиме группы танго-девайсов

Для записи в атрибуты в режиме группы танго-девайсов необходимо отправить запрос:

- Для всей группы запрос должен быть таким:

    ```json
    {
    	"type_req": "write_attr_gr",
  		"attr_name": "Attribute name",
    	"id": "Request id",
    	"argin": "value or [array]",
    	"dimX": "only for Image type",
    	"dimY": "only for Image type"
    }
    ```
    
- Для отдельного девайса из группы запрос должен быть таким:

    ```json
    {
    	"type_req": "write_attr_dev",
    	"attr_name": "Attribute name",
  		"device_name": "Device name",
    	"id": "Request id",
    	"argin": "value or [array]",
    	"dimX": "only for Image type",
    	"dimY": "only for Image type"
    }
    ```
    
Для возможности записи данных в атрибуты, они должны быть перечислены в Property `Attributes` с постфиксом `wrt`, либо с постфиксом `onlywrt`. С `onlywrt` атрибут не будет внесён в список обновления.


#### запись в атрибуты в клиентном режиме

В клиентом режиме возможна запись в атрибуты в любых танго-устройствах. Соответствующие права должны быть прописаны в базе и проверка проводится в подключённом модуле AuthDS. Подробнее описано в разделе [Клиентная запись в атрибуты](#клиентная-запись-в-атрибуты)

#### общая информация по командам

Запуск команд возможен только для зарегистрированных в базе пользователей. Соответствующие авторизация и аутентификация должна проводится в танго-девайсе, определяемом в свойстве AuthDS. В зависимости от типа авторизации, в клиентских приложениях должен быть либо прописан url с дополнительными параметрами `ws(wss)://адрес:порт?дополнительные-параметры` (для типов авторизации SIMPLE и RANDIDENT) , либо после подключения, с отправлением запроса на сервер.

Проверка осуществляется через TANGO девайс, прописанный в свойстве AuthDS.
Также возможна смена пользователя. Смена проиходит только если аутентификация для нового пользователя проходит успшно.

- Этот сервер должен содержать метод `check_user(const Tango::DevVarStringArray (*argin)`, возвращающий true или false. Используется для типа авторизации SIMPLE. Если вы хотите сменить имя команды установите `command_name_for_check_user=НОВОЕ_ИМЯ_МЕТОДА_ДЛЯ_CHECK_USER` in Property "Options"
   * **\(\*argin)[0]** = login
   * **\(\*argin)[1]** = password
   
   login password отправляются либо при подключении. Должны быть прописаны в url ws(wss)://ip_or_hostname:port?login=zzz&password=zzz`. 
   Либо после подключения, отправлением сообщения:
   
   
   ```json
	{
		"type_req": "change_user_smpl",
		"id": "id запроса",
		"login": "login",
		"password": "password"
	}
   ```

- Либо должен содержать метод `check_user_ident(const Tango::DevVarStringArray (*argin)`, возвращающий true или false. Используется для всех типов RANDIDENT
   * **\(\*argin)[0]** = login
   * **\(\*argin)[1]** = rand_ident
   * **\(\*argin)[2]** = rand_ident_hash

   Обязательно должна быть учтена последовательность и размер.

- Также сервер должен содержать метод `check_permissions(const Tango::DevVarStringArray (*argin)`, применяемый для аутентификации. В него передаётся массив, содержащий перечисленные ниже данные. Данный метод должен возвращать true или false. Если вы хотите сменить имя команды установите `command_name_for_check_permission=НОВОЕ_ИМЯ_МЕТОДА_ДЛЯ_CHECK_PERMISSIONS` in Property "Options"
   * **\(\*argin)[0]** — Танго девайс
   * **\(\*argin)[1]** — запускаемая команда
   * **\(\*argin)[2]** — Ip, с которого производится запуск
   * **\(\*argin)[3]** — login


Сама процедура проверки прав пользователей определяется в сервере, заданном в AuthDS. Должны лишь быть сохранены количество и последовательность вводимых параметров.

## клиентный запуск команд и чтение данных с атрибутов или pipe

В режимах, отличных от `SERVER` возможны чтение данных с атрибутов и pipe, а также запуск команд и запись данных в атрибуты на танго модулях (кроме ReadOnly режимов). Перечень возможных режимов с кратким описанием приведены [здесь](#режимы-работы-tango-модуля)

#### клиентное чтение атрибутов и pipe
При чтении атрибута нужно отправить сообщение в данном формате:

```json
{
	"type_req": "attr_device_cl or attr_group_cl",
	"id": "id запроса",
	"device_name": "имя девайса или alias или паттерн для группы",
	"attributes": ["Перечень атрибутов, либо один атрибут в формате value"],
	"pipe": ["pipe_name","attr_name;param"]
}
```

"type_req" : 
 - <b>attr_device_cl</b> - для одного девайса
 - <b>attr_group_cl</b> - для группы девайсов

Если в свойстве для атрибутов выставлен `__all_attrs__`, считываются данные со всех атрибутов танго-модуля.

Также, если требуется определить формат вывода данных с конкретных атрибутов, к имени атрибута нужно добавить необходимый параметр.

```
AttrName;par1=val;par2
```

Для выставления необходимых параметров для конкретных атрибутов из pipe, к массиву `pipe` следует добавить перечень атрибутов с необходимыми параметрами.

Ответ в следующем формате:

Для девайса:

```json
{
	"event": "read",
	"type_req": "attr_device_cl",
	"device_name": "имя девайса или alias",
	"id_req": "id запроса",
	"data": {
		"attrs": {
			"attribute_name": {
				"data": "data",
				"set": "if writable attribute"
			}
		},
		"pipe": {
				"attribute_name": "value",
				"other_attribute": ["value", "value"]
		}
	}
}
```

Для группы:

```json
{
	"event": "read",
	"type_req": "attr_group_cl",
	"id_req": "Request id",
	"data": {
		"attrs": {
			"device_name": {
				"attribute_name": {
				"data": "data",
				"set": "if writable attribute"
				}
			}
		},
		"pipe": {
			"device_name": {
			"attr_name": "данные",
			"attr_name_2": ["массив", "данных"]
			}
		}
	}
}
```

[Старая версия](./old_version.md#client-mode-attributes). Чтобы использовать старую версию допишите в Property `Options` - `array_out`

В зависимости от типа читаемых атрибутов (Scalar, Spectrum,  Image) меняется выводимый формат. Для Scalar — это единственное значение в виде строки, числа или булевого значения. Для Spectrum — это массив вида [ … ], также определено значение `"dimX"` размерность спектра. Для  Image— это это массив вида [ … ], также определено значение `"dimX"` и `"dimY"` -  размерность Image.
В случае ошибки, возвращается JSON_ERROR_MESSAGE. Формат данного сообщения описан в разделе  "[Формат возвращаемых ошибок](#формат-возвращаемых-ошибок)"

#### клиентный запуск команд

Для запуска команды нужно отправить сообщение в данном формате:

```json
{
	"type_req": "command_device_cl",
	"id": "id запроса",
	"device_name": "имя девайса или alias",
	"command_name": "имя команды"
}
```

`command_name` должен быть только в формате value. Также можно к имени команды добавить дополнительные параметры для управления выводимым форматом. [Дополнительные параметры для атрибутов, pipe и команд](#дополнительные-параметры-для-атрибутов-pipe-и-команд)

```
CommandName;par1=val;
```

Ответ в следующем формате:

```json
{
	"event": "read",
	"type_req": "command_device_cl",
	"id_req": "id запроса",
	"data": {
		"command_name": "имя команды",
		"device_name": "имя девайса или alias",
		"argout": "данные или [массив данных]"
	}
}
```

Соответствующие права должны быть прописаны в базе и проверка проводится в подключённом модуле AuthDS.
В случае ошибки, возвращается JSON_ERROR_MESSAGE. Формат данного сообщения описан в разделе  "[Формат возвращаемых ошибок](#формат-возвращаемых-ошибок)"

Также возможен запуск команд с выводом в двоичном формате. Для этого к имени команды (в `command_name`) должно быть добавлено `;bindata`. Обратите внимание, что данный вывод поддерживается только для команд с типом возвращаемого значения `Tango::DEVVAR_CHARARRAY`.

#### клиентная запись в атрибуты

Запись в атрибуты возможна в не `readonly` клиентных режимах.
 
```json
{
	"type_req": "write_attr_dev_cl",
	"device_name": "Device name",
	"attr_name": "Attribute name",
	"id": "Request id",
	"argin": "value or [array]",
	"dimX": "only for Image type",
	"dimY": "only for Image type"
}
```

Здесь `"dimX"` и  `"dimY"` используются только для массивов типа `Image`. Для `Spectrum` `"dimX"` выставляется автоматически, исходя из присланных данных.


## работа с событиями

Работа с событиями возможна во всех режимах.

Возможна подписка на следующие типы событий: `CHANGE_EVENT`, `PERIODIC_EVENT`, `ARCHIVE_EVENT`, `USER_EVENT`

Для подписки на события в одном из серверных режимов укажите список атрибутов в [Property для событий](#перечень-property-для-определения-tango-устройства)

Данные с событий приходят в следующем формате:

```json
{
	"event": "read",
	"type_req": "from_event",
	"event_type": "Event type",
	"timestamp": 1501324867,
	"attr": "attribute name",
	"data": "value or array"
}
```


#### подписка на события

<b style="color:blue;">Только для клиентного режима!</b>

В данный момент поддерживаются типы события `CHANGE_EVENT`, `PERIODIC_EVENT`, `ARCHIVE_EVENT`, `USER_EVENT`.

Для подписки на события нужно отправить сообщение в данном формате:

```json
{
	"type_req": "eventreq_add_dev",
	"id": "id",
	"change": {
		"name_of_device": "atrribute_name or array of names",
		"name_of_other_device": "atrribute_name"
	},
	"periodic": {
		"name_of_device": "atrribute_name or array of names",
		"name_of_other_device": "atrribute_name"
	},
	"user": {
		"name_of_device": "atrribute_name or array of names",
		"name_of_other_device": "atrribute_name"
	},
	"archive": {
		"name_of_device": "atrribute_name or array of names",
		"name_of_other_device": "atrribute_name"
	}
}
```

Для управления форматом вывода атрибутов к имени нужно добавить постфикс. [Подробнее здесь](#изменение-точности-и-форматирование-выводимых-значений-атрибутов-pipe-и-команд-типа-с-плавающей-запятой)

Ответ, в случае успеха, приходит в следующем формате

```json
{
	"event":"read",
	"type_req": "eventreq_add_dev", 
	"id_req": 2, 
	"resp": [
		{
		"device": "name/of/device", 
		"attribute": "attribute name", 
		"event_type": "Event type", 
		"event_sub_id": 2
		}
	]
}
```

Здесь `"event_sub_id"` - id подписки на событие. Его можно использовать при дальнейшей [отписки от события.](#частичная-отписка-от-событий) 


Данные возникновении событий приходят в следующем формате

```json
{
	"event": "read",
	"type_req": "from_event",
	"event_type": "Event type",
	"timestamp": 1501324867,
	"attr": "attribute name",
	"data": "value or array"
}
```

#### полная отписка от событий

<b style="color:blue;">Только для клиентного режима!</b>

Для отписки от всех событий, на которые подписаны, нужно отправить сообщение:

```json
{
	"type_req": "eventreq_off",
	"id": "id"
}
```

#### частичная отписка от событий

<b style="color:blue;">Только для клиентного режима!</b>

Для отписки от отдельных событий, нужно отправить:

```json
{
	"type_req": "eventreq_rem_dev",
	"id": "id",
	"event_sub_id": 12345
}
```

Здесь `"event_sub_id"`, id подписки на события, которая была произведена [ранее](#подписка-на-события)

#### получение id подписки

<b style="color:blue;">Только для клиентного режима!</b>

Если вы хотите получить id подписки на событие, произведённой вами ранее, нужно отправить

```json
{
	"type_req": "eventreq_check_dev",
	"id": "id",
	"device": "name/of/device", 
	"attribute": "attribute name", 
	"event_type": "Event type"
}
```

Ответ будет слудующим:

```json
{
	"event":"read",
	"type_req": "eventreq_check_dev", 
	"id_req": 2, 
	"data":
	{
		"device": "name/of/device", 
		"attribute": "attribute name", 
		"event_type": "Event type", 
		"event_sub_id": 1234
	}
}
```

Если подписка не найдена, значение для `"event_sub_id"` будет `-1`

## использование USERANDIDENT для авторизации.

В Property `Options` должно быть написано `tident=rndid`

Также возможна проверка пользователей методом USERANDIDENT (либо USERANDIDENT2) (использования случайного выражения).
При авторизации происходит проверка не логина и пароля, а логина и хэша (md5, sha ... и так далее) из присланного пользователю случайного слова/числа плюс идентификатора пользователя, хранящегося у него, к примеру, в localStorage. `md5(rand+ident)`
Как это будет делаться на стороне клиента, дело разработчика. Также сама проверка проходит вне данного модуля. На танго-девайс отвечающий за авторизацию в метод `check_user_ident` отправляется три значения

* **login** - ну тут всё понятно
* **rand_ident** - случайное число/слово хранящееся/сгенерированное у клиента
* **rand_ident_hash** - хэш(rand_ident+клиентское число/слово)

Для данного метода есть два типа USERANDIDENT и USERANDIDENT2. Основные отличия в том, что при режиме USERANDIDENT2 значения для `login` , `rand_ident`, `rand_ident_hash` передаются не при подключении, а после успешного подключения отправлением специальных JSON команд. [Подробнее про JSON можно прочитать здесь](http://www.json.org/json-ru.html)


#### авторизация методом USERANDIDENT во время подключения

В Property `Options` должно быть написано `tident=rndid`

При использовании данного метода, при подключении запускается вэбсокет с параметрами указанными после `?`.
Пример: `ws(wss):адрес :порт?login=логин&id_ri=ххх&rand_ident=xxx&id_ri=xxx&rand_ident_hash=xxx`

Для работы данного метода в модуле, отвечающем за авторизацию, должен быть реализован метод `check_user_ident`, возвращающий `bool`, и принимающий `const Tango::DevVarStringArray *argin`.

Соответственно, в метод `check_user_ident` отправляются присланные значения для `login` , `rand_ident`, `rand_ident_hash`. При успешном результате сеанс присваивается пользователю, дальнейшие права проверяются уже при аутентификации.

#### авторизация методом USERANDIDENT после подключения

В Property `Options` должно быть написано `tident=rndid`

Для авторизации нужно отправить:

  ```json
  {
  	"type_req": "rident",
  	"id": "id запроса запуска команды",
  	"login": "логин пользователя",
  	"rident": "случайное число/слово",
  	"rident_hash": "к примеру, вычисленный хэш"
  }
  ```

На сервере проверяются все переданные параметры, и, если всё нормально, высылается ответ об успешном прохождении авторизации следующего формата.

  ```json
  {
  	"event": "read",
  	"type_req": "rident",
  	"id_req": "id запроса запуска команды",
  	"success": true
  }
  ```

Стоит отметить, что с точки зрения безопасности, разработчик клиента и AuthDS сервера должен предусмотреть возможности смены значения `КЛЮЧ`, с которым высчитывается `MD5("rident"+MD5("КЛЮЧ"))`. Потому-что в данном случае перехват и `rident` и `rident_hash` равносилен перехвату логина и пароля, так-как они будут действительны и при следующем подключении.

#### авторизация методом USERANDIDENT2 после подключения

В Property `Options` должно быть написано `tident=rndid2`

В общем представлении процесс выглядит так:

- Пользователь открывает страницу. Для запуска команд на сервере, пользователь должен пройти авторизацию. Если пользователь пытается запустить команду без авторизации, ему приходит сообщение об ошибке:

  ```json
  {
  	"event": "error",
  	"type_req": "command or command_device etc..",
  	"name_req": "Имя запроса",
  	"id_req": "id запроса. Либо число, либо строка",
  	"err_mess": "Send request for rand_identification. For details read the manual."
  }
  ```
   Для запуска процесса авторизации пользователь должен отправить сообщение с запросом случайного числа. На сервер при подключении пользователя отправляется его логин, с запросом о получении случайного числа.

   ```json
   {
    "type_req": "rident_req",
    "id": "id запроса запуска команды",
    "login": "логин пользователя"
   }
   ```

- Сервер генерирует случайное число, сохраняет его. Отправляет клиенту ответ следущего вида

  ```json
  {
  	"event": "read",
  	"type_req": "rident_req",
  	"id_req": "id запроса запуска команды",
  	"rident": "случайное число"
  }
  ```

- Клиент вычисляет (в зависимости от требований авторизационного модуля) нужный ответ, и отправляет серверу. К примеру, это может быть MD5("присланное число"+MD5("пароль")). Ответ отправляется в следующем формате:

  ```json
  {
  	"type_req": "rident_ans",
  	"id": "id запроса запуска команды",
  	"login": "логин пользователя, если не высылался ранее",
  	"rident_hash": "к примеру, вычисленный хэш"
  }
  ```

- На сервере проверяются все переданные параметры, и, если всё нормально, высылается ответ об успешном прохождении авторизации следующего формата.

  ```json
  {
  	"event": "read",
  	"type_req": "rident_ans",
  	"id_req": "id запроса запуска команды",
  	"success": true
  }
  ```

Если что-то не так, высылается сообщение об ошибке.

Стоит отметить, что запросы должны идти последовательно. То есть сначала запрос случайного числа, затем вычисленный ответ. При попытке выполнения команд между этими запросами, или возникновении ошибок, случайное число обновляется, поэтому нужно будет снова начать с шага 1.

## авторизация методом permission_www

В Property `Options` должно быть написано `tident=permission_www`

Этот метод используется, если проводится только авторизация. `"login"` и `"password"` либо при подключении, (Должны быть прописаны в url ws(wss)://ip_or_hostname:port?login=zzz&password=zzz`), либо после подключения, отправлением сообщения:   
   
   ```json
	{
		"type_req": "change_user_smpl",
		"id": "id запроса",
		"login": "login",
		"password": "password"
	}
   ```
При отправлении `"login"` и `"password"` аутентификация проходит автоматически, при любых значениях. Проверка происходит только после выполнения команд требующих авторизации. Данные отправляются в команду `authProxy->command_inout("check_permissions_www", argin);`. Авторизация считается пройденной, если не было выброшено исключение. В `check_permissions_www` передаётся 5 значений в следующем порядке:
 - **argin[0]** - login
 - **argin[1]** - пароль
 - **argin[2]** - deviceName (либо имя девайса в танго-формате, или шаблон имени девайса)
 - **argin[3]** - commandName (имя команды) + `"/write"`, например `command_name/write`
 - **argin[4]** - IP

## использование записи в журнал при выполении команд
Для активации этой возможности нужно во-первых, определить `uselog` Property `"Options"` ([подробнее про формат опций здесь](#свойство-options)), во-вторых, сервер, отвечающий за авторизацию, должен содержать метод `send_log_command_ex`, который записывает в таблицу следующие данные (здесь argin список передаваемых значений в массив `vector <string>`, и в соответсвующем танго-девайсе `Tango::DevVarStringArray *argin` ):
 - **id** - autoincrement
 - **argin[0]** = timestamp_string (UNIX_TIMESTAMP)
 - **argin[1]** = login
 - **argin[2]** = deviceName (либо имя девайса в танго-формате, или шаблон имени девайса)
 - **argin[3]** = IP
 - **argin[4]** = commandName (имя команды)
 - **argin[5]** = commandJson (вводимая команда в json формате)
 - **argin[6]** = statusBool (1 если запуск успешен, иначе 0)
 - **argin[7]** = isGroup (1 если используется группа, иначе 0)

Сама процедура записи определяется в соответствующем танго-девайсе (AuthDS). Должны лишь быть сохранены последовательность аргументов и имя метода. Возвращается bool.

## формат возвращаемых ошибок

Возвращаемые ошибки при чтении атрибутов имеют следующий формат:

```json
{
	"event": "error",
	"type_req": "attribute",
	"err_mess": "Сообщение ошибки"
}
```

При запуске команд, или запросах с pipe возвращаемые ошибки имеют следующий формат:

```json
{
	"event": "error",
	"type_req": "Тип запроса",
	"name_req": "Имя запроса",
	"id_req": "id запроса. Либо число, либо строка",
	"err_mess": "Либо сообщение, либо [массив сообщений]"
}
```

Если при запросах не использовалось `name_req`, в ответе его тоже не будет.

## список типов запроса

  - **[read_pipe](#чтение-с-pipe-в-командном-режиме)**
  - **[read_pipe_dev](#чтение-с-pipe-в-командном-режиме)**
  - **[read_pipe_gr](#чтение-с-pipe-в-командном-режиме)**
  - **[command](#запуск-команд-в-режиме-танго-девайса)**
  - **[command_group](#запуск-команд-в-режиме-группы-танго-девайсов)**
  - **[command_device](#запуск-команд-в-режиме-группы-танго-девайсов)**
  - **[read_attr](#чтение-атрибутов-с-прослушиваемого-tangodevice-по-запросу)**
  - **[read_attr_dev](#чтение-атрибутов-с-группы-прослушиваемых-tangodevice-по-запросу)**
  - **[read_attr_gr](#чтение-атрибутов-с-группы-прослушиваемых-tangodevice-по-запросу)**
  - **[rident_req](#авторизация-методом-userandident2-после-подключения)**
  - **[rident_ans](#авторизация-методом-userandident2-после-подключения)**
  - **[rident](#авторизация-методом-userandident-после-подключения)**
  - **[attr_device_cl](#клиентное-чтение-атрибутов-и-pipe)**
  - **[command_device_cl](#клиентный-запуск-команд)**
  - **[write_attr_dev_cl](#клиентная-запись-в-атрибуты)**
  - **[write_attr](#запись-в-атрибуты-в-режиме-танго-девайса)**
  - **[write_attr_gr](#запись-в-атрибуты-в-режиме-группы-танго-девайсов)**
  - **[write_attr_dev](#запись-в-атрибуты-в-режиме-группы-танго-девайсов)**
  - **[attr_group_cl](#клиентное-чтение-атрибутов-и-pipe)**
  - **[change_user_smpl](#общая-информация-по-командам)**
