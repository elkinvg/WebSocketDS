# WebSocketDS

Имеются две версии модуля:

- **server_mode** - Режим, в котором девайсы, и прослушиваемые атрибуты для них прописываются в `Property`. Команды выполняются только для данных девайсов. Разрешения для команд выставляются на соответствующем модуле.
- **client_mode** - Режим, в котором перечень команд и атрибутов полностью управляется клиентом.

## установка в linux

Для успешной компиляции должны быть установлены библиотеки TANGO и компилятор с поддержкой c++11. Также должны быть установлены **libboost-system libboost-system-dev libssl**

В директории есть Makefile для g++. Данный Makefile был генерирован POGO, и при стандартных сборках TANGO подходит в большинстве случаев. Для успешного запуска данного Makefile, должна присутствовать директория определённая в `MAKE_ENV = /usr/local/share/pogo/preferences` (по умолчанию. При необходимости нужно поправить). В скриптах, содержащихся в директории, определены необходимые переменные окружения для сборки проекта.

По умолчанию компиляция идёт в режиме OPTIMIZED (-O2). Для компиляции в режиме DEBUG (-g -D_DEBUG) нужно запустить `make RTYPE=debug`, предварительно набрав `make clean`

## установка в windows

TODO:

## server mode

В этом типе модуля, прослушиваемое устройство (группа), а также список атрибутов, полностью прописываются в TANGO-property.

Подробнее про [server mode](./server_mode/README_RUS.md)

Makefile для server mode в директории `./server_mode/`

## client mode

В этом типе модуля, список устройств и прослушиваемых атрибутов полностью задаётся клиентом, подключённым к WebSocket специальными командами

Подробнее про [client mode](./client_mode/README_RUS.md)

Makefile для client mode в директории `./client_mode/`

## список возможных значений в property Options

Свойство Options (array of strings) для танго-девайса имеет формат `opt1` либо `opt2=val`, где `opt` - имя опции, `val` - значение, если присутствует.

Перечень доступных опций:

- **group** - Без дополнительных значений. Использование групп девайс серверов. Свойство `DeviceServer` должно быть задано в соответствующем для групп формате (только для серверного режима).

- **uselog** - Без дополнительных значений. Использование записи в журнал при выполении команд. [Подробнее ниже](#использование-записи-в-журнал-при-выполении-команд)

- **useoldjson**- Без дополнительных значений. Если добавлен этот ключ, Для команд и чтения атрибутов будут ответы старого типа

- **tident**- С дополнительным значением. Используемый тип авторизации. Используются два типа , `permission_www` ([подробности ниже](#авторизация-методом-permission_www)), а также `smpl` - SIMPLE (он же используется по умолчанию)

- **command_name_for_check_user**- С дополнительным значением. Использование иного имени команды для аутентификации. По умолчанию `check_user`. Пример: `command_name_for_check_user=НОВОЕ_ИМЯ_МЕТОДА`

- **command_name_for_check_permission**- С дополнительным значением. Использование иного имени команды для авторизации. По умолчанию `check_permissions`. Пример: `command_name_for_check_permission=НОВОЕ_ИМЯ_МЕТОДА`

- **command_name_for_log**- С дополнительным значением. Использование иного имени команды для записи логов. По умолчанию `send_log_command_ex`. Пример: `command_name_for_log=НОВОЕ_ИМЯ_МЕТОДА`

- **maxnconn**- Максимальное число соединений. Если будет достигнут предел, последующие соединения будут прерваны ошибкой `400 Bad Request`. Если задано значение 0, количество соединений не будет ограничено.

- **maxbuffsize**- Максимальный размер буфера для каждого соединения в КиБ. Значение по умолчанию 1000. Возможные значения от 1 до 10000 (если указать значения не входящие в заданный диапазон будет выставлено значение по умолчанию). При превышении заданного максимального размера буфера, соединение будет прервано со стороны сервера;

## авторизация и аутентификация

Запуск команд возможен только для пользователей, прошедших проверку в AuthDS. Соответствующие авторизация и аутентификация должна проводится в танго-девайсе, определяемом в свойстве AuthDS.

В зависимости от типа авторизации, в клиентских приложениях должен быть либо прописан url с дополнительными параметрами `ws(wss)://адрес:порт?дополнительные-параметры` (для типов авторизации SIMPLE и RANDIDENT) , либо после подключения, с отправлением запроса на сервер.

Проверка осуществляется через TANGO девайс, прописанный в свойстве AuthDS.
Также возможна смена пользователя. Смена проиходит только если аутентификация для нового пользователя проходит успешно.

AuthDS должен содержать метод `check_user(const Tango::DevVarStringArray (*argin)`, возвращающий true или false. Используется для типа авторизации SIMPLE. Если вы хотите сменить имя команды установите `command_name_for_check_user=НОВОЕ_ИМЯ_МЕТОДА_ДЛЯ_CHECK_USER` in Property "Options"

В `check_user` проходит аутентификация пользователя. Все дальнейшие команды будут производится от имени этого пользователя, если аутентификация прошла успешно.

- **argin[0]** - login
- **argin[1]** - password

login password отправляются либо при подключении. Должны быть прописаны в url `ws(wss)://ip_or_hostname:port?login=zzz&password=zzz`.
Либо после подключения, отправлением сообщения:

```json
{
  "type_req": "change_user_smpl",
  "id": "Request id",
  "login": "login",
  "password": "password"
}
```

При выполнении каждой команды, требующей авторизации, на сервер отправляются данные по команде.

Для этого сервер должен содержать метод `check_permissions(const Tango::DevVarStringArray (*argin)`, применяемый для авторизации. В него передаётся массив, содержащий перечисленные ниже данные:

- **argin[0]** — Танго девайс
- **argin[1]** — запускаемая команда
- **argin[2]** — Ip, с которого производится запуск
- **argin[3]** — login

Данный метод должен возвращать true или false. Если вы хотите сменить имя команды установите `command_name_for_check_permission=НОВОЕ_ИМЯ_МЕТОДА_ДЛЯ_CHECK_PERMISSIONS` in Property `"Options"`

---

**Сама процедура проверки прав пользователей определяется в сервере, заданном в AuthDS. Должны лишь быть сохранены количество и последовательность вводимых параметров.**

---

### авторизация методом permission_www

В Property `Options` должно быть написано `tident=permission_www`

При использовании этого метода, проводится только авторизация. Аутентификация проходит автоматически, при отправлении любых `"login"` и `"password"`

Проверка происходит только после выполнения команд требующих авторизации. Данные отправляются в команду `authProxy->command_inout("check_permissions_www", argin);`. Авторизация считается пройденной, если не было выброшено исключение. В `check_permissions_www` передаётся 5 значений в следующем порядке:

- **argin[0]** - login
- **argin[1]** - пароль
- **argin[2]** - deviceName (либо имя девайса в танго-формате, или шаблон имени девайса)
- **argin[3]** - commandName (имя команды) + `"/write"`, например `command_name/write`
- **argin[4]** - IP

## использование записи в журнал при выполении команд

Для активации этой возможности нужно во-первых, определить `uselog` Property `"Options"` ([подробнее про формат опций здесь](#свойство-options)), во-вторых, сервер, отвечающий за авторизацию, должен содержать метод `send_log_command_ex`, который записывает в таблицу следующие данные (здесь argin список передаваемых значений в массив `vector <string>`, и в соответсвующем танго-девайсе `Tango::DevVarStringArray*argin` ):

- **id** - autoincrement
- **argin[0]** = timestamp_string (UNIX_TIMESTAMP)
- **argin[1]** = login
- **argin[2]** = deviceName (либо имя девайса в танго-формате, или шаблон имени девайса)
- **argin[3]** = IP
- **argin[4]** = commandName (имя команды)
- **argin[5]** = commandJson (вводимая команда в json формате)
- **argin[6]** = statusBool (1 если запуск успешен, иначе 0)
- **argin[7]** = isGroup (1 если используется группа, иначе 0)

Если вы хотите сменить имя команды установите `command_name_for_log=НОВОЕ_ИМЯ_МЕТОДА` in Property "Options"

Сама процедура записи определяется в соответствующем танго-девайсе (AuthDS). Должны лишь быть сохранены последовательность аргументов и имя метода. Возвращается bool.

## precision options

Precision options выставляются по разному, в зависимости от адресата.

Для запросов, выставлением дополнительного ключа `precision`, формат которого зависит от типа запроса. Это либо объект, либо значение.

Для выставления значений точности атрибутов из `Property`, к имени атрибута в свойстве следует добавить `;prec=N`, где N - это требуемая точность. Пример: `AttrDevDouble;prec=10`

Следует учитывать максимально возможную точность. Подробнее про double можно посмотреть [здесь](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8), про float [здесь](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9).

Также возможно выставление дополнительных флагов форматирования:

- **precf** - выставление флага std::fixed
- **precs** - выставление флага std::scientific

Пример вывода для числа 1476379200 типа double с precision=10

- **prec=10** - выводится 1476379200
- **precf=10** - выводится 1476379200.0000000000
- **precs=10** - выводится 1.4763792000e+009

Пример вывода для числа 1476379200 типа double с precision по умолчанию

- **precf** - выводится 1476379200.000000
- **precs** - выводится 1.476379e+009

## вывод об ошибках

```json
{
  "event": "error",
  "type_req": "Type of request",
  "id_req": "Request id. If it was",
  "err_mess": "Or string, or array of string or object",
  "type_err": "type of error"
}
```

`err_mess` - формат значений данного ключа зависит от запроса. Для событий это объект формата:

```json
{
  "err_mess": [
    {
      "device": "sys/tg_test/2",
      "event_type": "periodic",
      "attribute": "float_scalar",
      "data": "Event channel is not responding anymore, maybe the server or event system is down"
    }
  ]
}
```

`type_err` - тип ошибки. Возможные типы ошибок [перечислены ниже](#типы-ошибок)

### типы ошибок

- **init_failed** - Ошибка инициализации прослушиваемого девайса
- **auth_check** - Ошибка аутентификации. Неверный логин или пароль
- **auth_perm** - Ошибка аутентификации. Нет доступа
- **auth_server_err** - Ошибка аутентификации. Сервер недоступен
- **is_not_valid** - Неправильный запрос
- **not_supp** - Нет поддержки. Например для команды с данным типом аргумента
- **not_supp_in_curr** - Нет поддержки в текущем режиме
- **unknown_req_type** - Неизвестный типа запроса
- **check_request** - Проверить запрос. Неправильный формат, или не найден необходимый ключ
- **tango_exc** - TANGO exception
- **unavailable_devs** - All device unavailable
- **event_err** - Исключение из событийных данных
- **event_dev_err** - Исключение из прослушиваемого устройства
- **check_code** - Данный тип ошибки не должен выдаваться при нормальной работе
- **subscr_not_found** - Не найдена подписка с данным id. Может возникнуть при отписке от событий
- **commun_failed** - Tango::CommunicationFailed
- **conn_failed** - Tango::ConnectionFailed
- **unknown_exc** - Исключение неизвестного типа
- **not_subscr_yet** - Ещё нет подписчиков. Возникает при командах по управлению подписками, если подписок ещё не было.
- **from_event_sub** - Ошибка возникшая при подписке на события в серверном режиме
- **device_not_in_group** - Запрос был отправлен девайсу не найденному в группе
