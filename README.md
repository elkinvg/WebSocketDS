WebSocketDS
===========

- **[Установка.](#Установка)**
- **[Перечень property для определения Tango устройства.](#Перечень-property-для-определения-tango-устройства)**
- **[Перечень атрибутов](#Перечень-атрибутов)**
- **[Свойство Options](#Свойство-options)**
- **[Простое использование только с чтением атрибутов](#Простое-использование-только-с-чтением-атрибутов)**
 - **[Чтение атрибутов с прослушиваемого TangoDevice.](#Чтение-атрибутов-с-прослушиваемого-tangodevice)**
 - **[Чтение атрибутов с группы прослушиваемых TangoDevice.](#Чтение-атрибутов-с-группы-прослушиваемых-tangodevice)**
- **[Чтение с pipe подключаемых устройств](#Чтение-с-pipe-подключаемых-устройств)**
  - **[Чтение с pipe в атрибутном режиме](#Чтение-с-pipe-в-атрибутном-режиме)**
  - **[Чтение с pipe в командном режиме](#Чтение-с-pipe-в-командном-режиме)**
- **[Дополнительные параметры для атрибутов, pipe и команд](#Дополнительные-параметры-для-атрибутов-pipe-и-команд)**
 - **[Команды с выводом в двоичном формате](#Команды-с-выводом-в-двоичном-формате)**
 - **[Изменение точности и форматирование выводимых значений атрибутов, pipe и команд типа с плавающей запятой](#Изменение-точности-и-форматирование-выводимых-значений-атрибутов-pipe-и-команд-типа-с-плавающей-запятой)**
 - **[Установление периодичности вывода значений для атрибутов](#Установление-периодичности-вывода-значений-для-атрибутов)**
- **[Запуск команд](#Запуск-команд)**
 - **[Запуск команд в режиме танго-девайса](#Запуск-команд-в-режиме-танго-девайса)**
 - **[Запуск команд в режиме группы танго-девайсов](#Запуск-команд-в-режиме-группы-танго-девайсов)**
 - **[Общая информация по командам](#Общая-информация-по-командам)**
- **[Использование USERANDIDENT для аутентификации.](#Использование-userandident-для-аутентификации)**
- **[Использование записи в журнал при выполении команд](#Использование-записи-в-журнал-при-выполении-команд)**
- **[Формат возвращаемых ошибок](#Формат-возвращаемых-ошибок)**

## Установка.
Для успешной компиляции должны быть установлены библиотеки TANGO и компилятор с поддержкой c++11. Также должны быть установлены __libboost-system libboost-system-dev libssl__

В директории есть Makefile для g++. Данный Makefile был генерирован POGO, и при стандартных сборках TANGO подходит в большинстве случаев. Для успешного запуска данного Makefile, должна присутствовать директория определённая в  `MAKE_ENV = /usr/local/share/pogo/preferences` (по умолчанию. При необходимости нужно поправить). В скриптах, содержащихся в директории, определены необходимые переменные окружения для сборки проекта.

По умолчанию компиляция идёт в режиме OPTIMIZED (-O2). Для компиляции в режиме DEBUG (-g -D_DEBUG) нужно запустить `make RTYPE=debug`, предварительно набрав `make clean`

## Перечень property для определения Tango устройства.
 - **Port** — Прослушиваемый порт при соединении; (DevShort)
 - **DeviceServer** - tango id используемого устройства. Пример: `test/psw/group`. В случае использования групп устройств, используется шаблон. Параметром шаблона может быть простое имя устройства или шаблон имени устройства (например, `domain_*/family/member_*`); (string)
 - **Attributes** — список атрибутов устройства, которые вы хотите считывать; (array of string)
 - **Commands** — список команд устройства, которые вы хотите выполнять через WS; (array of string)
 - **PipeName** - PipeName для pipe устройства, также список атрибутов с опциями для вывода; (array of string)
 - **AuthDS** — танго сервер, отвечающий за аутентификацию пользователя, при наличии исполняемых команд; (string)
 - **Secure** — установите true, для использования защищённого wss соединения, иначе false; (bool)
 - **Certificate** — полный путь к используемому сертификату (if Secure = true); (string)
 - **Key** - полный путь к используемому файлу с  Private key (if Secure = true); (string)
 - **MaxNumberOfConnections** - максимальное число соединений. Если будет достигнут предел, последующие соединения будут прерваны ошибкой `400 Bad Request`. Если задано значение 0, количество соединений не будет ограничено.; (DevUShort)
 - **MaximumBufferSize** - максимальный размер буфера для каждого соединения в КиБ. Значение по умолчанию 1000. Возможные значения от 1 до 10000 (если указать значения не входящие в заданный диапазон будет выставлено значение по умолчанию). При превышении заданного максимального размера буфера, соединение будет прервано со стороны сервера; (DevULong)
 - **ResetTimestampDifference** - Разница таймстампов (в секундах) после которого будет произведена перезагрузка WS сервера. Расчёт разницы производится в методе CheckPoll между тайстампом обновляемым в методе UpdateData и текущим таймстампом. Минимальное значение 60.; (DevUShort)
 - **Options** - дополнительные опции. Перечень дополнительных опций для девайса в формате `opt1;opt2=val;opt3`. Подробнее про список дополнительных опций будет [указано ниже](#Свойство-options). (string)

 <h2><b><font color="red"> В методе CheckPoll проверяется сколько секунд прошло после последнего запуска метода UpdateData. Если значение превысит, заданное в property, количество секунд, произойдёт перезагрузка девайс-сервера.  Не выставляйте значение polling для UpdateData близким к значению ResetTimestampDifference </font></b></h2>

## Перечень атрибутов
 - **JSON** - текущий JSON-output; (DevString)
 - **TimestampDiff** - текущая разница таймстампов (обновляется в методе CheckPoll. Значение Polling по умолчанию для него 10 секунд); (DevULong)
 - **NumberOfConnections** - текущее число клиентов (соединений). (DevULong)

## Свойство Options
  Свойство Options для танго-девайса имеет формат `opt1;opt2=val;opt3`, где `opt` - имя опции, `val` - значение, если присутствует. Опции разделяются точкой с запятой `;`, ставить её нужно только между опциями.

  Перечень доступных опций:
  - **group** - Без дополнительных значений. Использование групп девайс серверов. Свойство `DeviceServer` должно быть задано в соответствующем для групп формате.
  - **uselog** - Без дополнительных значений. Использование записи в журнал при выполении команд.  [Подробнее ниже](#Использование-записи-в-журнал-при-выполении-команд)
  - **tident** - С дополнительным значением. Используемый тип аутентификации. Используются два типа `rndid` - RANDIDENT ([подробности ниже](#Использование-userandident-для-аутентификации)), `smpl` - SIMPLE (он же используется по умолчанию)

## Простое использование только с чтением атрибутов

Для использования  WS только для чтения атрибутов, следует определить `Port`,  `DeviceServer` (или Group) и список `Attributes` которые будут читаться. При использовании защищённого wss соединения, нужно установить свойство `Secure` в true, а также определить  `Certificate`  и `Key`

#### Чтение атрибутов с прослушиваемого TangoDevice.

Пример формата получаемых данных будет следующим:
```json
{
	"event": "read",
	"type_req":"attribute",
	"data":
	[
		{
			"attr": "имя_атрибута",
			"qual": "VALID",
			"time": 1475580424,
			"data": 128
		},
	]
}
```

 * **"event"** - тип события, в данном случае чтение
 * **"type_req"** - тип полученных данных, в данном случае attribute. Данные с прослушиваемых атрибутов.
 * **"data"** - Получаемые данные. (Атрибуты)

   * **"attr"** — имя прослушиваемого атрибута.
   * **"qual"** — `Tango::AttrQuality` Возможные значения: `"VALID`", `"INVALID"`,`"ALARM"`, `"CHANGING"`, `"WARNING"`;
   * **"time"** — UNIX_TIMESTAMP
   * **"data"** — Данные. В зависимости от типа читаемых атрибутов (Scalar, Spectrum,  Image) меняется выводимый формат. Для Scalar — это единственное значение в виде строки, числа или булевого значения. Для  Spectrum — это массив вида [ … ], также определено значение `"dimX"` размерность спектра. Для  Image— это это массив вида [ … ], также определено значение `"dimX"` и `"dimY"` -  размерность Image.

При возникновении ошибок при чтении атрибутов выводится сообщение JSON сообщение об ошибке. Формат описан ниже в разделе `"[Формат возвращаемых ошибок](#Формат-возвращаемых-ошибок)"`

#### Чтение атрибутов с группы прослушиваемых TangoDevice.

Пример формата получаемых данных c группы девайсов будет следующим:

```json
{
	"event": "read",
	"type_req":"group_attribute",
	"data":
	{
		"name/tango/device_from_group" :
		{
			"attr": "имя_атрибута",
			"qual": "VALID",
			"time": 1475580424,
			"data": 128
		}
	}
}
```

* **"event"** - тип события, в данном случае чтение
* **"type_req"** - тип полученных данных, в данном случае `group_attribute`. Данные с прослушиваемых атрибутов.
* **"data"** - Получаемые данные. (Атрибуты)

  * **"name/tango/device_from_group"** - имя танго-девайса из группы
  * **"attr"** — имя прослушиваемого атрибута.
  * **"qual"** — `Tango::AttrQuality` Возможные значения: `"VALID`", `"INVALID"`,`"ALARM"`, `"CHANGING"`, `"WARNING"`;
  * **"time"** — UNIX_TIMESTAMP
  * **"data"** — Данные. В зависимости от типа читаемых атрибутов (Scalar, Spectrum,  Image) меняется выводимый формат. Для Scalar — это единственное значение в виде строки, числа или булевого значения. Для  Spectrum — это массив вида [ … ], также определено значение `"dimX"` размерность спектра. Для  Image— это это массив вида [ … ], также определено значение `"dimX"` и `"dimY"` -  размерность Image.


Если возникает ошибка при чтении с отдельного девайса из группы, формат data для него будет таким:

```json
{
	"name/tango/device_from_group" : "Error message"
}
```

## Чтение с pipe подключаемых устройств

Чтение возможно в атрибутном и командном режимах:
 - В атрибутном режиме, данные с pipe считываются при обновлении данных вместе с атрибутами и добавляются в соответствующий JSON-output.
 - В командном режиме, данные с pipe считываются при запросе. Отправляется JSON-input в необходимом формате (описано ниже).

#### Чтение с pipe в атрибутном режиме

PipeName имеет тип `array of string`. Для чтения данных с pipe подключаемых устройств в атрибутном режиме, в Свойство PipeName[0] должно быть добавлено pipe_name - имя pipe читаемого устройства.
Для форматирования вывода отдельных сегментов pipe, нужно добавить в свойство строки с именами сегмента, и необходимыми типами форматирования. Подробнее описано в разделе "[Дополнительные параметры для атрибутов, pipe и команд](#Дополнительные-параметры-для-атрибутов-pipe-и-команд)"

В атрибутном режиме подключаться можно к единственному pipe из девайса.

При наличии PipeName в свойстве, к JSON, получаемом при чтении атрибутов, добавляется строка в следующем формате:

__В случае успеха:__

  a) __для девайса:__

  ```json
	{ "данные_с атрибутов" : "данные",
		"pipe":
		{
			"attrName1" : "данные в формате зависящем от типа",
			"attrName2" : ["данные в формате", "зависящем от типа"]
		}
	}
  ```
  b) __для группы:__

 ```json
	{ "данные_с атрибутов" : "данные",
		"pipe":
		{
			"nameof/tango/device":
			{
				"attrName1" : "данные в формате зависящем от типа",
				"attrName2" : ["данные в формате", "зависящем от типа"]
			}
		}
	}
 ```

__В случае ошибки:__

  a) __для девайса:__

   ```json
	{ "данные_с атрибутов" : "данные",
		"pipe" : "Error message"
	}
   ```

   b) __для группы:__

   ```json
	{ "данные_с атрибутов" : "данные",
		"pipe":
		{
			"nameof/tango/device": "Error message"
		}
	}
   ```

   `"Error message"` - может быть также массивом сообщений в фомате `["Сообщение1", "Сообщение2"]`

#### Чтение с pipe в командном режиме

Для чтения с pipe в командном режиме на сервер отправляется JSON сообщение в следующем формате:

```json
{
	"read_pipe or read_pipe_dev or read_pipe_gr": "PipeName",
	"device_name": "!!!Только при чтении с конкретного девайса в групповом режиме!!!",
	"id": "id для идентификации запроса"
}
```
* __"read_pipe or read_pipe_dev or read_pipe_gr"__: Имя читаемого pipe. Используется `"read_pipe"`в режиме одного девайса. `"read_pipe_dev"` в режиме `group`, для чтения с конкретного девайса из группы. `"read_pipe_gr"` в режиме `group`, для чтения со всех девайсов из группы.
* __"device_name"__: Имя девайса в режиме `group`, для чтения с конкретного девайса из группы.
* __"id"__: Идентификация запроса.  Значение для id может быть как числом, так и строкой. В случае, если id не указан, возвращается `"id": "None"`.

Для форматирования вывода отдельных сегментов pipe, нужно добавить в свойство строки с именами сегмента, и необходимыми типами форматирования. Подробнее описано в разделе "[Дополнительные параметры для атрибутов, pipe и команд](#Дополнительные-параметры-для-атрибутов-pipe-и-команд)"

  - Ответ для `"read_pipe"`в режиме одного девайса будет таким:

  ```json
  {
  	"event": "read",
  	"type_req": "pipe",
  	"id_req": 1,
  	"data": {
  		"AttrName": "данные",
  		"AttrName2": ["данные", "данные"]
  	}
  }
  ```

  - Для `"read_pipe_dev"` в режиме `group`:

  ```json
  {
  	"event": "read",
  	"type_req": "pipe_dev",
  	"device_name": "name/tango/device_from_group",
  	"id_req": "id запроса запуска команды",
  	"data": {
  		"AttrName": "данные",
  		"AttrName2": ["данные", "данные"]
  	}
  }
  ```

  - Для чтения со всех девайсов из группы `"read_pipe_gr"` в режиме `group`:

  ```json
  {
  	"event": "read",
  	"type_req": "pipe_gr",
  	"device_name": "name/tango/device_from_group",
  	"id_req": "id запроса запуска команды",
  	"data" : {
  		"name/tango/device_from_group": {
  			"AttrName": "данные",
  			"AttrName2": ["данные", "данные"]
  		},
  		"name/tango/other_device_from_group": "Возможное сообщение об ошибке, либо [массив сообщений]"
  	}
  }
  ```

 При возниконовении ошибки, в зависимости от режима работы и типа команды, сообщение либо добавляется в JSON-output для группы в раздел девайса, в котором возникла ошибка, либо выводится общее сообщение об ошибке в формате, описанном ниже в разделе "[Формат возвращаемых ошибок](#Формат-возвращаемых-ошибок)"


## Дополнительные параметры для атрибутов, pipe и команд

Для выставления дополнительных параметров к имени атрибута или команды в свойстве следует добавить строку в следующем формате `;param=val` если требуется значение, или `;param` если значение не требуется.

Также можно добавлять несколько параметров в аналогичном формате.
Пример:

```
CommandOrAttrName;par1=val;par2;par3=34
```

В случае pipe в атрибутном режиме в свойстве PipeName можно выставить дополнительно параметры для отдельных атрибутов, передаваемых через pipe. Все имена атрибутов с параметрами должны идти после имени для DevicePipe.
Пример:

```
PipeName
AttrName;par1=val;par2
```

В случае pipe в командном режиме, параметры для отдельных атрибутов выставляются в property `Commands`. К имени атрибута должно добавляться `;pipecomm`, а также необходимый параметр.

```
AttrName;pipecomm;par1=val;par2
```

Список доступных на данный момент параметров для команд и атрибутов:

 - Для атрибутов, команд и pipe: **precf**, **precs**, **prec**
 - Только для атрибутов: **niter**
 - Только для команд: **bindata**

#### Команды с выводом в двоичном формате

Для вывода в двоичном формате к имени команды в свойстве танго-девайса "Commands" должно быть добавлено `;bindata`.

Обратите внимание, что данный вывод поддерживается только для команд с типом возвращаемого значения `Tango::DEVVAR_CHARARRAY`. Также, если используется групповой режим, команды выполняются только для отдельных девайсов из группы. Для всей группы данный формат не поддерживается.

В случае какой-либо ошибки возвращается `Tango::DEVVAR_CHARARRAY` в формате __err{JSON_ERROR_MESSAGE}__. То есть первые три символа char `err`, затем сообщение об ошибке в формате JSON. Формат сообщения описан в разделе  "[Формат возвращаемых ошибок](#Формат-возвращаемых-ошибок)"

#### Изменение точности и форматирование выводимых значений атрибутов, pipe и команд типа с плавающей запятой

По умолчанию, для вывода данных атрибутов, pipe и команд стоит setprecision(5). Для выставления других значений точности, к имени атрибута в свойстве следует добавить `;prec=N`, где N - это требуемая точность. Пример: `AttrDevDouble;prec=10`

Следует учитывать максимально возможную точность. Подробнее про double можно посмотреть [здесь](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8), про float [здесь](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D1%81_%D0%BF%D0%BB%D0%B0%D0%B2%D0%B0%D1%8E%D1%89%D0%B5%D0%B9_%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%BE%D0%B9).

Также возможно выставление дополнительных флагов форматирования:

- **precf** - выставление флага std::fixed
- **precs** - выставление флага std::scientific

Пример вывода для числа 1476379200 типа double с precision=10

- **;prec=10** - выводится 1476379200
- **;precf=10** - выводится 1476379200.0000000000
- **;precs=10** - выводится 1.4763792000e+009

Пример вывода для числа 1476379200 типа double с precision по умолчанию
- **;precf** - выводится 1476379200.000000
- **;precs** - выводится 1.476379e+009


Выставление точности для возвращаемых значений команд проходит аналогично.  Для выставления других значений точности, к имени команды в свойстве следует добавить `;prec=N`, либо другое, из перечисленного выше.

#### Установление периодичности вывода значений для атрибутов

Для отдельных атрибутов можно выставить периодичность вывода. Для выставления перодичности к имени атрибута в свойстве следует добавить `;niter=N/M` либо `;niter=N`

Здесь
 - **N** - вывод раз в N итераций.  (unsigned short)
 - **M** - в какую итерацию в пределах периода выводить. `M` должно быть меньше `N`. По умолчанию `0` (unsigned short)


## Запуск команд
Для запуска команд через  WS, нужно определить список запускаемых команд в свойстве  Commands. Команды, перечисленные в свойстве, должны содержаться в прослушиваемом девайсе. Если используется группа девайсов, перечисляемые команды должны быть во всех девайсах из группы (с аналогичной сигнатурой и типом возвращаемого значения. Сверяется Tango::CommandInfo для команд)

#### Запуск команд в режиме танго-девайса

Команды запускаются входящим json сообщением вида:

```json
{"command" : "nameOfCommand", "argin" : ["1","2","3"]}
```

`argin` в зависимости от метода, отправляется либо в виде единичного значения, либо в виде массива. Если команда не принимает аргументов, `argin` не  указывать. Также можно указывать `"id": id`, для идентификации запроса. В случае, если id не указан, возвращается `"id": "None"`. значение для id может быть как числом, так и строкой.

Ответ в успешном случае будет таким:
```json
{
	"event": "read",
	"type_req": "command",
	"data": {
		"command_name": "имя команды",
		"id_req": "id запроса запуска команды",
		"argout": "Данные. Единственное значение [или массив]"
	}
}
```

В случае ошибки, возвращается JSON_ERROR_MESSAGE. Формат данного сообщения описан в разделе  "[Формат возвращаемых ошибок](#Формат-возвращаемых-ошибок)"

#### Запуск команд в режиме группы танго-девайсов

Команды запускаются json сообщением.

- Для всей группы запрос будет таким:

  ```json
	{
		"command_group" : "nameOfCommand",
		"argin" : ["1","2","3"]
	}
  ```

Ответ, будет таким:

  ```json
  {
  	"event": "read",
  	"type_req": "command",
  	"data": {
  		"command_name": "имя команды",
  		"id_req": "id запроса запуска команды",
  		"argout": {
  			"name/tango/device_from_group" : "Данные в формате зависящем от возвращаемого типа",
  			"name/tango/other_device_from_group": {
  				"errors": "Возможное сообщение об ошибке, либо [массив сообщений]"
  			}
  		}
  	}
  }  
  ```  

- Для отдельного девайса из группы запрос будет таким:

  ```json
	{
		"command_device" : "nameOfCommand",
		"device_name": "nameof/tango/device",
		"argin" : ["1","2","3"]
	}
  ```

  Ответ, в успешном случае, будет таким:

  ```json
  {
  	"event": "read",
  	"type_req": "command_device",
  	"data": {
  		"command_name": "имя команды",
  		"device_name": "name/tango/device_from_group",
  		"id_req": "id запроса запуска команды",
  		"argout": "Данные в формате зависящем от возвращаемого типа"
  	}
  }
  ```

  В случае ошибки, возвращается JSON_ERROR_MESSAGE. Формат данного сообщения описан в разделе  "[Формат возвращаемых ошибок](#Формат-возвращаемых-ошибок)"


#### Общая информация по командам

Запуск команд возможен только для зарегистрированных в базе пользователей. Соответствующие авторизация и аутентификация должна проводится в танго-девайсе, определяемом в свойстве AuthDS.  Соответственно в скрипте должен быть прописан url такого типа: `ws(wss):адрес :порт?'login=логин&password=пароль.` Если логин и пароль не прописан, или не проходит проверку, выкидывается ошибка такого типа: `«WebSocket connection to 'ws://…… ' failed: Error during WebSocket handshake: Unexpected response code: 400»`
Проверка осуществляется через  TANGO сервер, прописанный в свойстве  AuthDS.
1. Этот сервер должен содержать метод `check_user(const Tango::DevVarStringArray (*argin)` и возвращать true или false
   * **\(\*argin)[0]** = «login»,
   * **\(\*argin)[1]** = «password». Обязательно должна быть учтена последовательность и размер.
2. Также сервер должен содержать метод `check_permissions(const Tango::DevVarStringArray (*argin)` , в который передаётся массив, содержащий перечисленные ниже данные, и возвращать true или false
   * **\(\*argin)[0]** — Танго девайс
   * **\(\*argin)[1]** — запускаемая команда
   * **\(\*argin)[2]** — Ip, с которого производится запуск
   * **\(\*argin)[3]** — login

Сама процедура проверки прав пользователей определяется в сервере, заданном в AuthDS. Должны лишь быть сохранены количество и последовательность вводимых параметров.

## Использование USERANDIDENT для аутентификации.

Также возможна проверка пользователей методом USERANDIDENT (использования случайного выражения).
При авторизации происходит проверка не логина и пароля, а логина и хэша (md5, sha ... и так далее) из присланного пользователю случайного слова/числа плюс идентификатора пользователя, хранящегося у него,к примеру, в localStorage. `md5(rand+ident)`
Как это будет делаться на стороне клиента, дело разработчика. Главное, чтобы в метод check_permission, который вызывается при каждой команде, отправлялись дополнительно четыре значения. Они должны передаваться при открытии вэбсокета ... то есть, как я писал ранее, `ws(wss):адрес :порт?login=логин&id_ri=ххх&rand_ident=xxx&rand_ident_hash=xxx`

 * **login** - ну тут всё понятно
 * **id_ri** - идентификатор случайного числа (тут тоже вроде понятно ...)
 * **rand_ident** - случайное число/слово присланное с сервера
 * **rand_ident_hash** - хэш(rand_ident+клиентское число/слово)

Также в танго-девайсе, через который проводится авторизация (AuthDS), должен быть определён метод `check_permissions_ident`, в котором будет проводиться проверка. Он возвращает true или false. Ну и конечно важно, чтобы сохранялась последовательность и количество аргументов. Сейчас последовательность такая

 - **permission_data[0]** = `deviceName`; // имя девайса на котором выполняется команда
 - **permission_data[1]** = `commandName`; // имя команды
 - **permission_data[2]** = `parsedGet["ip"]`; // айпишник пользователя
 - **permission_data[3]** = `parsedGet["login"]`; // логин пользователя
 - **permission_data[4]** = `parsedGet["id_ri"]`; // идентификатор случайного числа
 - **permission_data[5]** = `parsedGet["rand_ident_hash"]`; // хэш
 - **permission_data[6]** = `parsedGet["rand_ident"]`; // случайное число/слово

В общем представлении процесс выглядит так:

1. Пользователь открывает страницу. На сервер при подключении пользователя отправляется его логин, с запросом о получении случайного числа.
2. Сервер считывает из базы идентификатор пользователя. Генерирует случайное число, сохраняет его (к примеру тоже в БД) и создаёт md5(случайное число+идентификатор). Естественно после того, как клиент завершит сеанс, случайное число должно быть удалено, и при следующем подключении должно генерироваться другое. Пользователю отправляется это число, и id этого числа. В качестве id, в принципе, можно использовать timestamp (с миллисекундами).
3. Клиент запускает вэбсокет `ws(wss):адрес :порт?login=логин&id_ri=ххх&rand_ident=xxx&id_ri=xxx&rand_ident_hash=xxx`
4. На сервере проверяются все переданные, при открытии вэбсокета, параметры, и, если всё нормально, открывает вэб-сокет с возможностью отправления сообщений на сервер. Если что-то не так, то при попытке клиента что-то отправить он будет получать JSON сообщение об ошибке  `"err_mess": "Permission denied"`, в формате описанном в разделе "[Формат возвращаемых ошибок](#Формат-возвращаемых-ошибок)".

Естественно, стоит предусмотреть случаи обрыва только вэбсокетов, потому-что тут, скорее всего, будет открываться новое соединение и выполняться тогда будет только с шага 3 со старыми параметрами.

## Использование записи в журнал при выполении команд
Для активации этой возможности нужно во-первых, определить `uselog` Property `"Options"` ([подробнее про формат опций здесь](#Свойство-options)), во-вторых, сервер, отвечающий за авторизацию, должен содержать метод `send_log_command_ex` который записывает в таблицу следующие данные (здесь argin список передаваемых значений в массив `vector <string>`, и в соответсвующем танго-девайсе `Tango::DevVarStringArray *argin` ):
 - **id** - autoincrement
 - **argin[0]** = timestamp_string (UNIX_TIMESTAMP)
 - **argin[1]** = login
 - **argin[2]** = deviceName (либо имя девайса в танго-формате, или шаблон имени девайса)
 - **argin[3]** = IP
 - **argin[4]** = commandName (имя команды)
 - **argin[5]** = commandJson (вводимая команда в json формате)
 - **argin[6]** = statusBool (1 если запуск успешен, иначе 0)
 - **argin[7]** = isGroup (1 если используется группа, иначе 0)

Сама процедура записи определяется в соответствующем танго-девайсе (AuthDS). Должны лишь быть сохранены последовательность аргументов и имя метода. Возвращается bool.

## Формат возвращаемых ошибок

Возвращаемые ошибки при чтении атрибутов имеют следующий формат:

```json
{
	"event": "error",
	"type_req": "attribute",
	"err_mess": "Сообщение ошибки"
}
```

При запуске команд, или запросах с pipe возвращаемые ошибки имеют следующий формат:

```json
{
	"event": "error",
	"type_req": "Тип запроса",
	"name_req": "Имя запроса",
	"id_req": "id запроса. Либо число, либо строка",
	"err_mess": "Либо сообщение, либо [массив сообщений]"
}
```

Список типов запроса:
  - **read_pipe**
  - **read_pipe_dev**
  - **read_pipe_gr**
  - **command**
  - **command_group**
  - **command_device**
